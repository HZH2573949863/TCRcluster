# TCRcluster

## Description
TCRcluster is a tool used for calculating TCR CDR3 distances and cluster the TCR CDR3 sequences based on corresponding peptide sequences.

The aim of TCRcluster project is to design an algorithm to calculate the T cell receptors distance using the TCR-epitope pairs data and then cluster the TCR CDRH3 sequences. After mapping CDR3 sequences in different clusters with antigen species, the correlation between CDR3 motifs and T cell binding antigens can be concluded. The realization of this project is essential for the analysis of T cell reactions and the clinical diagnosis of pathogens in patients by detecting the T cell CDR3 sequences.

The biomedical significance of our project lies in various diagnosis and clinical treatment areas.
Firstly, TCRcluster project can help reflect the immune response state of T cells in the human body and detect autoimmune diseases like autoimmune pancreatitis. Secondly, it is possible to design targeted therapies for autoimmune diseases because the antigens can be determined by applying our TCR distance calculation and clustering method. Lastly, TCRcluster project can predict the antigens of new TCRs. For example, suppose we have the clustering result of the test CDR3 data with recognized antigens. In that
case, we can predict the probable antigen of a new CDR3 sequence by comparing it to the existing CDR3 sequences in different clusters.

## Work Flow
![image](https://github.com/HZH2573949863/TCRcluster/blob/main/flow.png)

## Personal Contribution
My work is the visualization of the clustering result. I think the fascinating thing about my work is that I managed to design the Fruchterman-Reingold algorithm in my style based on my knowledge of physics instead of using the package that networkx provided to lay out the position of nodes. In addition, after working out the initial version of my algorithm, I continued improving my algorithm to abandon some unnecessary calculation processes and make the result more accurate.

In the visualization part, I chose to use the Fruchterman-Reingold algorithm to calculate TCR CDR3 sequences’ layout in visualization because it helped make the abstract dimension reduction of the distance data easy to understand, for it transforms the dimensionality reduction into a simulation of particle motion that happens in the real world rather than just using mathematical calculations to solve the problem. 

The Fruchterman-Reingold algorithm I designed differs from the algorithm published online. I treat the motion of the nodes in each unit time as a uniform linear motion. It is different from the online typical Fruchterman-Reingold algorithm, which calculated not only the forces but also the change in acceleration and velocity generated by the forces to perfectly simulate the actual situation. In my opinion, it is not necessary to calculate the acceleration because if I set the state of nodes being stationary at the beginning of each time unit, the final position of nodes after adequate iterations of calculation will not be significantly affected. In addition, calculating the acceleration will increase the algorithm’s running time. After weighing the pros and cons, I designed a more concise Fruchterman-Reingold algorithm which reduces some unnecessary calculations while ensuring the accuracy of the results. 

The comparison of online FR algorithm clustering result ("spring_layout" function in python package networkx v2.4) with my FR algorithm clusering result:
![image](https://github.com/HZH2573949863/TCRcluster/blob/main/comparison%20of%20FR%20algorithm.png)

Although I have made some improvements to the algorithm, there are still some limitations. Firstly, since the initial position of each CDR3 sequence node in the canvas is random, the final plot has certain randomness and may result in an unsatisfying visualization output. Some nodes may be far away from others belonging to the same cluster. According to some studies published before, the Fruchterman-Reingold algorithm can only achieve local optimization but not global optimization because the initial positions of nodes have an enormous impact on the final result. Increasing the number of repetitions might be one way to reduce the effect of randomness. Secondly, our visualization process takes much
time, especially when the input data is extensive since we need to iterate the calculation of the force condition and position change of each CDR3 sequence about 700 times. The algorithm’s complexity is O(n2), and if the input data is 300 CDRH3 sequences, the code will run approximately 7 min to get the result, which is relatively slow. To reduce the running time, I think it is possible to choose a more appropriate number of iterations depending on the number of nodes instead of using a fixed number of 700. For example, set the number of iterations twice the number of nodes. It can reduce the time waste for calculating the position change after the system achieves the dynamic equilibrium state.
